[INCLUDE=presentation]
Title         : Formally Secure Compartmentalizing Compilation
Author        : Catalin Hritcu
Affiliation   : Inria Paris
Reveal Url    : ../reveal.js
Reveal Theme  : white
Colorizer     : text
Logo          : False
Html Header   :
    <script src="../../stuff/script.js"></script>
    <link rel="stylesheet" href="../../stuff/style.css" id="custom_style">
Package       : xypic
HTML Meta     : clear
~Pre,~Code: language=text
Package       : tikz
Package       : mathtools
Tex Header    : \usetikzlibrary{decorations.shapes%
                               ,decorations.pathmorphing}
Toc Depth     : 2

~ MathDefs
[INCLUDE=../../stuff/latex.tex]
~

[//]: <> ( Madoko works poorly with Firefox, but nothing we can do about that )

[//]: <> (TODO P2: Maybe Switch to latest working Reveal.js ? One can set it like this:)
[//]: <> (Reveal Url    : https://cdn.jsdelivr.net/reveal.js/2.6.2 )
[//]: <> (Problem: main font of the slides changes to inferior one)

[//]: <> (TODO "P" is currently very overloaded: )
[//]: <> (- partial program P )
[//]: <> (- program identifier P (or C) ‚Äì could use some different "unicode font" for this? )
[//]: <> (    ùêÇ and ùó£, ‚í∏ and ‚ìÖ, ùìí and ùìü, ... https://yaytext.com/double-struck/)
[//]: <> (- procedure identifier ‚ÑÇ.P ‚Äì rename this to ‚ÑÇ.p! )

[//]: <> (TODO Why not use K for components to distinguish them from a contexts? ùïÇ := ‚ÑÇ | ‚Ñô )

[//]: <> (MOSTLYFIXED Florian)
[//]: <> ( The current font doesn't look fixed width to me for the subscripts )
[//]: <> ( Probably those don't exist in the font I chose, and )
[//]: <> (  different people are seeing different font substitutions, )
[//]: <> (  only some of which are fixed width)
[//]: <> (- (Florian:) exactly, didn't find a font with all subscript glyphs with fixed width.)
[//]: <> (  Maybe evermono but it has a completely f'd up license (shareware 25‚Ç¨ and only 3 cpus for its use...)


# Formally Secure Compartmentalizing Compilation #

~Center

**[C&#259;t&#259;lin Hri&#355;cu, Inria Paris](http://prosecco.gforge.inria.fr/personal/hritcu/)**

[18th International School on Foundations of Security Analysis and Design (FOSAD)](http://www.sti.uniurb.it/events/fosad18/)

[Bertinoro, Italy](https://goo.gl/maps/oqzrpd6aMfr), 27-28 August 2018
~

[//]: <> (----------------------------------------------------------------------------)

[//]: <> ( # Formally Secure (Compartmentalizing) Compilation )
[//]: <> ( ## (1h) High-level vision )
[//]: <> ( Goals: )
[//]: <> ( - explain high-level story, outlining the rest of the course )
[//]: <> ( - impress and motivate, our work is cool, foundational, and practical )

[//]: <> ( Slides in PowerPoint )
[//]: <> ( - here is a draft: )
[//]: <> ( http://prosecco.gforge.inria.fr/personal/hritcu/talks/2018-08-26-Fomally-Secure-Compilation-FOSAD.pdf )

[//]: <> ( (DONE) Secure compilation is something even broader )
[//]: <> ( - the broader thing explained in the Dagstuhl report and talk: )
[//]: <> ( http://prosecco.gforge.inria.fr/personal/hritcu/talks/2018-05-14-Secure-Compilation-Goals-and-Attackers-Dagstuhl.pdf )
[//]: <> ( - this course is focused on formally secure compartmentalizing compilation )

[//]: <> ( (DONE) Secure compilation is not just about )
[//]: <> ( - devising formal criteria )
[//]: <> ( but also about )
[//]: <> ( - devising efficient enforcement mechanisms )
[//]: <> ( - devising effective proof / verification techniques )

[//]: <> ( WONTFIX: Are too much duplication or spoilers between this part )
[//]: <> (                 and the rest a problem? Is so how to deal with it? )
[//]: <> ( - try to stay as high-level as possible here )
[//]: <> ( - WONTFIX? try to leave out too advanced topics, like: )
[//]: <> (   + where is full abstraction, they won't know what that means )
[//]: <> (   + Do I want to explain the open problems so early? Why not? Could return to them too! )

# Content

[TOC]

# Correct compilation

## What's a compilation chain? (formally)
- **Source language**
- **Target language**
- **Compiler**
- {.fragment} Soon will also add: **Linker**!
- {.fragment} **Security enforcement can happen at all these levels**:
  + source language can have nice abstractions
  + target language (machine) can include loader,
    operating system support, cool hardware features, etc
  + compiler can do static analysis or insert security checks
  + {.fragment} **so we call it "secure compilation", not just "secure compilers"**

## Source language
- whole programs: `W‚Çõ`
- trace-based operational semantics: `W‚Çõ ‚áù t`
- real-world examples: Pascal, Rust, Java, C#, ML, Haskell, ...
- {.fragment} simplifying away details: well-formedness of programs (e.g. typing)

## Target language
- whole programs: `W‚Çú`
- trace-based operational semantics: `W‚Çú ‚áù t`
- real-world examples: ASM (x86, ARM, RISC-V), JVM, CIL, LLVM IR, ...
- {.fragment} simplifying assumption: exactly the same traces as for source

## Compiler
- a partial (math) function "`‚Üì`": `W‚Çõ‚Üì = W‚Çú`
  + from whole source programs (`W‚Çõ`) to whole target programs (`W‚Çú`)
- {.fragment} verified compilers are defined as such partial functions:
  + CompCert is a function in Coq
  + CakeML is a function in HOL
- {.fragment} real-world more complicated: rustc, javac, ocamlc, ghc, ...

## Simple compilation chain

### (running example)

## Simple source language: PROC
Imperative language with procedures
```
e ::= i                       integer value
    | x                       variable lookup (for now global)
    | x := e                  variable assignment (for now global)
    | e‚ÇÅ ‚äó e‚ÇÇ                 binary operations
    | e‚ÇÅ; e‚ÇÇ                  sequence
    | if e‚ÇÅ then e‚ÇÇ else e‚ÇÉ   conditional (tests if e‚ÇÅ is non-zero)
    | P(e)                    procedure call
    | arg                     read the current procedure's argument
    | exit                    terminate

D ::= P(arg) { e }            procedure declaration

W ::= D‚ÇÅ,...,D‚Çô               whole program (where main(arg) { e } ‚àà W)
```

## PROC operational semantics
```
W ‚ä¢ M, x                     ‚Üí  M, M[x]
W ‚ä¢ M, x:=i                  ‚Üí  M[x‚Ü¶i], i
W ‚ä¢ M, i‚ÇÅ‚äói‚ÇÇ                 ‚Üí  M, ‚äó(i‚ÇÅ,i‚ÇÇ)
W ‚ä¢ M, i;e‚ÇÇ                  ‚Üí  M, e‚ÇÇ
W ‚ä¢ M, if i then e‚ÇÇ else e‚ÇÉ  ‚Üí  M, e‚ÇÇ  when i ‚â† 0
W ‚ä¢ M, if 0 then e‚ÇÇ else e‚ÇÉ  ‚Üí  M, e‚ÇÉ
W ‚ä¢ M, P(i)                  ‚Üí  e[arg‚Ü¶i]  when P(arg) { e } ‚àà W
```
~Fragment
```
E ::=                 evaluation contexts (expressions with a hole [])
    [] | x := E | E ‚äó e‚ÇÇ | i‚ÇÅ ‚äó E | E; e‚ÇÇ | if E then e‚ÇÇ else e‚ÇÉ | P(E)

W ‚ä¢ M‚ÇÅ, e‚ÇÅ ‚Üí M‚ÇÇ, e‚ÇÇ
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äì‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
W ‚ä¢ M‚ÇÅ, E[e‚ÇÅ] ‚Üí M‚ÇÇ, E[e‚ÇÇ]

W ‚ä¢ M, E[exit] ‚Üí M, exit
```
~
~Fragment
```
InitS(W) = W ‚ä¢ [x‚Ü¶0|x], main(0)          initial state for W
W ‚ä¢ M, i and W ‚ä¢ M, exit                 final states
```
~

## Events and traces: PROC+IO
```
e ::= ... | input | output e          external input and output

W ‚ä¢ M, input    ‚Üí_{Input i}  M, i
W ‚ä¢ M, output i ‚Üí_{Output i} M, i
```
~Fragment
```
Œ± ::=                     events
    | œÑ                     silent event (m¬∑œÑ=m)
    | Input i               visible input
    | Output i              visible output

t ::=                     traces
    | Œ±‚ÇÅ¬∑...¬∑Œ±‚Çô¬∑Done        succesful termination
    | Œ±‚ÇÅ¬∑...¬∑Œ±‚Çô¬∑Loop        silent divergence
    | Œ±‚ÇÅ¬∑...¬∑Œ±‚Çô¬∑...         infinite trace
```
~
~Fragment
```
W ‚áù t ‚âú (‚àÉsf. ‚àÉm finite, InitS(W) ‚Üí*_t ‚àß t = m¬∑Done sf ‚àß sf final)
            ‚à® (‚àÉm finite. InitS(W) ‚Üíœâ_t ‚àß t = m¬∑Loop ‚àß execution infinite)
                       ‚à® (InitS(W) ‚Üíœâ_t ‚àß t infinite ‚àß execution infinite)
```
~

## Simple target language: REG+IO
Abstract machine with registers
```
instr ::= Nop                     do nothing
        | Halt                    terminate the program
        | Jal l                   direct jump-and-link
        | Jump r                  indirect jump to address in r
        | Bnz r l                 direct jump if r is non-zero
        | Label l                 declare code label (direct jump target)
        | Const i -> rd           put constant i in register
        | Copy rs -> rd           write value of rs to rd
        | BinOp r‚ÇÅ ‚äó r‚ÇÇ -> rd     write result of r‚ÇÅ ‚äó r‚ÇÇ to rd
        | Load *rp -> rd          dereference rp and put result in rd
        | Store rs -> *rp         write value in rs to addres in rp
        | Input rd                external input
        | Output rs               external output

W‚Çú ::= instr‚ÇÅ,...,instr‚Çô           (where no label is defined twice,
                                   and all used labels are defined)
```

## REG+IO operational semantics
```
W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M, R, PC+1                     when W‚Çú[PC] = Nop
W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M, R[R_RA‚Ü¶PC+1], offset_of(W‚Çú,l) when W‚Çú[PC] = Jal l,
W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M, R, R[r]                     when W‚Çú[PC] = Jump r
W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M, R, offset_of(W‚Çú,l)           when W‚Çú[PC] = Bnz r l and R[r] ‚â† 0
W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M, R, PC+1                     when W‚Çú[PC] = Bnz r l and R[r] = 0
W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M, R, PC+1                     when W‚Çú[PC] = Label l
W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M, R[rd‚Ü¶i], PC+1               when W‚Çú[PC] = Const i -> rd
W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M, R[rd‚Ü¶R[rs]], PC+1           when W‚Çú[PC] = Copy rs -> rd
W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M, R[rd‚Ü¶‚äó(R[r‚ÇÅ],R[r‚ÇÅ])], PC+1  when W‚Çú[PC] = BinOp r‚ÇÅ ‚äó r‚ÇÇ -> rd
W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M, R[rd‚Ü¶M[R[rp]]], PC+1        when W‚Çú[PC] = Load *rp -> rd
W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M[R[rp]‚Ü¶R[rs]], R, PC+1        when W‚Çú[PC] = Store rs -> *rp
W‚Çú ‚ä¢ M, R, PC ‚Üí_{Input i} M, R[rd‚Ü¶i], PC+1      when W‚Çú[PC] = Input rd
W‚Çú ‚ä¢ M, R, PC ‚Üí_{Output R[rs]} M, R, PC+1       when W‚Çú[PC] = Output rs
```
~Fragment
```
InitS(W‚Çú) = W‚Çú ‚ä¢ [addr‚Ü¶0 | addr], [r‚Ü¶0 | r], 0     initial states
W‚Çú ‚ä¢ M, R, PC final if W‚Çú[PC] = Halt               final states
                    or W‚Çú[PC] not defined
```
~

~Fragment
Simplifications: infinite memory+integers, programs not stored in memory
~

[//]: <> ( Note: the operational semantics initializes all memory to 0 )
[//]: <> ( (alternatively, the compiler would have to initialize )
[//]: <> ( the memory storing variables) )

## Simple compiler: PROC+IO to REG+IO

[//]: <> ( Original Reference from Jeremy and Carmine: )
[//]: <> (  https://drive.google.com/file/d/1mfExQ0eiqWpDTte0CQxK1d4RtKH8cHPQ/view?usp=sharing  )

- Simple compiler uses 6 registers:
  + `R_Res` contains results of previous expression
  + `R_Aux` used as an auxiliary
  + `R_One` contains 1
  + `R_Arg` used to pass arguments to functions
  + `R_RA` stores return address
  + `R_SP` stores stack pointer

- {.fragment} Memory layout:
  + addresses `0,...,n-1` store variables
  + addresses `n,...    ` store a stack

## Compilation of expressions
```
i‚Üì = Const i -> R_Res
x‚Üì = Const addr_of(x) -> R_Aux; Load *R_Aux -> R_Res
(x := e)‚Üì = e‚Üì; Const addr_of(x) -> R_Aux; Store R_Res -> *R_Aux
(e‚ÇÅ ‚äó e‚ÇÇ)‚Üì = e‚ÇÅ‚Üì; Push R_Res; e‚ÇÇ‚Üì; Pop R_Aux; BinOp R_Res ‚äó R_Aux -> R_Res
(e‚ÇÅ; e‚ÇÇ)‚Üì = e‚ÇÅ‚Üì; e‚ÇÇ‚Üì
(if e‚ÇÅ then e‚ÇÇ else e‚ÇÉ)‚Üì = e‚ÇÅ‚Üì; Bnz R_Res l‚ÇÅ;
                                e‚ÇÉ‚Üì; Bnz R_One l‚ÇÇ;
                                Label l‚ÇÅ; e‚ÇÇ‚Üì;
                          Label l‚ÇÇ
P(e)‚Üì = If declared(P) Then
          e‚Üì; Push R_Arg; Push R_RA; Copy R_Res -> R_Arg; Jal label_of(P);
              Pop R_RA; Pop R_Arg
        Else
          Error "Call to undeclared procedure P"
arg‚Üì = Copy R_Arg -> R_Res
exit‚Üì = Halt
input‚Üì = Input R_Res
(output e)‚Üì = e‚Üì; Output R_Res
```

## The rest of the compiler

- Compilation of procedure declaration:
```
(P(arg) { e })‚Üì = Label label_of(P); e‚Üì; Jump R_RA
```

- {.fragment} Stack management
```
Push r = Store r -> *R_SP; BinOp R_SP + R_One -> R_SP
Pop r = BinOp R_SP - R_One -> R_SP; Load *R_SP -> r
```

- {.fragment} Compilation of whole program `W = D‚ÇÅ,...,D‚Çô`:
```
W‚Üì = Const 1 -> R_One; Const |vars(W)| -> R_SP;
     Jal label_of(main); Halt; D‚ÇÅ‚Üì; ...; D‚Çô‚Üì
```

## Exercise: add while loop
- Extend the compilation chain with a while loop

~ Fragment
- Solution:

```
e := ... | while e‚ÇÅ do e‚ÇÇ

E ::= ... | while E do e‚ÇÇ

W ‚ä¢ M, while 0 do e‚ÇÇ ‚Üí M, 0
W ‚ä¢ M, while i do e‚ÇÇ ‚Üí M, (e‚ÇÇ; while i do e‚ÇÇ)  when i ‚â† 0

(while e‚ÇÅ do e‚ÇÇ)‚Üì = Label l‚ÇÅ; e‚ÇÅ‚Üì; Bnz R_Res l‚ÇÇ; Bnz R_One l‚ÇÉ;
                                   Label l‚ÇÇ; e‚ÇÇ‚Üì; Bnz R_One l‚ÇÅ;
                                   Label l‚ÇÉ
```
~

[//]: <> ( (TODO P2 (Catalin): to be kept private; have code for that in F* tutorial) )

## Backward Correct Compilation (BCC)

- BCC: `‚àÄW t. W‚Üì ‚áù t  ‚áí  W ‚áù t`
  + intuitively `t` is a bad attack trace

- {.fragment} BCC defined in terms of traces of coarse-grained events
  - {.fragment} striking a pragmatic balance between:
    + the properties one can express and preserve
    + the optimizations the compiler can perform
  - {.fragment} example: making `œÑ` actions observable would be a disaster!
    + compiler would have to preserve number of reduction steps
    + can't build a compiler at all, even less an efficient one

## BCC ‚áî Trace Property Preservation (TP)
- TP: `‚àÄW œÄ. W sat œÄ  ‚áí  W‚Üì sat œÄ`
  - where `œÄ` is a trace property:
    + i.e. property on traces
    + i.e. a set of accepted traces (`œÄ ‚àà 2^Trace`)
  - and `W sat œÄ ‚âú ‚àÄt. W ‚áù t  ‚áí  t ‚àà œÄ`
- {.fragment} TP (property-full) = what we want: source-level reasoning
- {.fragment} BCC(property-free) = how to prove it: mapping traces

## Example trace properties

- $\pi_{\square\lnot\alpha} = \{t ~|~ \alpha \not\in t \}$
  - program should never cause bad event $\alpha$
  [//]: <> ( - real world example: avoid errors, outputing sensitive data, etc. )

- {.fragment} $\pi_{\square\lnot \mathtt{Done}}= \{t ~|~ \mathtt{Done} \not\in t\}$
  - program should not terminate
  [//]: <> ( - real world example: systems that must perform continuously )

- {.fragment} $\pi_{\lozenge\alpha} = \{ t ~|~ \alpha \in t \}$
  - program should eventually cause the good event $\alpha$
  [//]: <> ( - real world example: eventual termination (not sure of this) )

## Counterexamples to BCC

[//]: <> ( TODO: We went much overboard with the # of counterexamples here. )
[//]: <> (       Should focus on a few best ones ) )

## Example: Bad compilation #1

- Q: What happens if we don't Push and Pop on procedure calls?
- {.fragment} A: Register cluttering, wrong results.

- {.fragment} Example: Consider the program
```
W = main(arg) { P(1); output(arg) }; P(arg) { 1 }
```
  Then, if the compiler doesn't push/pop on calls:
```
W‚Üì = Const 1 -> R_One; Const |vars(W)| -> R_SP; Jal label_of(main); Halt;
     Label label_of(main); Const 1 -> R_Res; Copy R_Res -> R_Arg; Jal label_of(P);
                           Copy R_Arg -> R_Res; Output R_Res; Jump R_RA;
     Label label_of(P); Const 1 -> R_Res; Jump R_RA
```
Trace: `t = Output 1; Output 1; Output 1; Output 1; ...`
but this is not an acceptable trace of the source program.

## Exercise: Bad compilation #2

- Q: What happens if we don't Push and Pop on binary operations?
- {.fragment} A: Register cluttering, wrong results.
  [//]: <> ( + Q: Is there any clever way to compile arithmetic expression )
  [//]: <> (      without a stack? What would Xavier do? )
  [//]: <> (   A: For DSSS'17 Xavier uses a stack machine. )
```
W = main(arg) { output(2 + (1 + 1)) }
```
  Can only do the trace
`t = output(4)`
```
W‚Üì = Const 1 -> R_One; Const |vars(W)| -> R_SP; Jal label_of(main); Halt;
     Label label_of(main); Const 2 -> R_Res; Copy R_Res -> R_Aux;
       Const 1 -> R_Res; Copy R_Res -> R_Aux; Const 1 -> R_Res;
       BinOp R_Res + R_Aux -> R_Res;
       BinOp R_Res + R_Aux -> R_Res
```
  The compiled program can only have trace `t = Output 3`.

[//]: <> ( TODO (Jeremy): remove vertical scroll )

## Optimizations
- Q: Can we simplify `e+e` to `2*e`?
```
(e‚ÇÅ ‚äó e‚ÇÇ)‚Üì = If ‚äó=+ and e‚ÇÅ=e‚ÇÇ Then (2 * e‚ÇÅ)‚Üì Else ... as before ...
```
- {.fragment} A: Not always!
  + `output 2 + output 2` computes `4` with trace `Output 2;Output 2`
  + `2 * output 2` computes `4` with trace `Output 2`, this is different!
  + need static analysis to check whether e could have side-effects
  + memory write also side-effect:
    `(x++)+(x++)` not the same as `2*(x++)`

- {.fragment} Another example optimization:
  + Code without side-effects and whose result not used can be removed
  + e.g. `e‚ÇÅ; e‚ÇÇ` can be simplified to `e‚ÇÇ`,
    if `e‚ÇÅ` does no memory writes, no inputs, and no outputs

## Semantics mismatch
- We could make the semantics of `x:=i` return `0`. This alone breaks BCC.
```
W ‚ä¢ M, x:=i ‚Üí M[x‚Ü¶i], 0
```
- {.fragment} Source expression `P = output (x:=5)` now has the trace `Output 0`.
- {.fragment} `P‚Üì` still has the trace `Output 5` though.
```
P‚Üì = output(x:=5)‚Üì = (x := 5)‚Üì; Output R_Res
= Const 5 -> R_Res; Const addr_of(x) -> R_Aux; Store R_Res -> *R_Aux; Output R_Res
```
- {.fragment} Q: How to solve this issue?
  + Modify the compiler:
```
    (x := e)‚Üì = e‚Üì; Const addr_of(x) -> R_Aux; Store R_Res -> *R_Aux; Const 0 -> R_Res
```
  + Change back the source semantics:
```
    W ‚ä¢ M, x:=i ‚Üí M[x‚Ü¶i], i
```
  + Modify the target semantics (strange in this case):
```
    W‚Çú ‚ä¢ M, R, PC ‚ÜíœÑ M[R[rp]‚Ü¶R[rs]], R[R_Res‚Ü¶0], PC+1  when W‚Çú[PC] = Store rs -> *rp
```
    still have to ensure this does not break anything else in the compiler

[//]: <> ( TODO: Would be nice to also have an example that uses inputs )
[//]: <> (       and thus has one than one trace )

[//]: <> ( TODO (Jeremy): our events are Input i and Output i  )


## BCC ‚áí TP proof (easy)
- BCC (know): `‚àÄW t. W‚Üì ‚áù t ‚áí W ‚áù t`
- TP (show): `‚àÄW œÄ. W sat œÄ ‚áí W‚Üì sat œÄ`
  + where `W sat œÄ ‚âú ‚àÄt. W ‚áù t ‚áí t ‚àà œÄ`
  + and `W‚Üì sat œÄ ‚âú ‚àÄt. W‚Üì ‚áù t ‚áí t ‚àà œÄ`
- {.fragment} Let `W` and `œÄ` so that `W sat œÄ`.
- {.fragment} Let `t` so that `W‚Üì ‚áù t`.
- {.fragment} To show: `t ‚àà œÄ`.
- {.fragment} By BCC from `W‚Üì ‚áù t` we get that `W ‚áù t`.
- {.fragment} From definition of `W sat œÄ` we conclude that `t ‚àà œÄ`.

## BCC ‚áê TP proof (more interesting, still easy)
- TP (know): `‚àÄW œÄ. W sat œÄ ‚áí W‚Üì sat œÄ`
  + where `W sat œÄ ‚âú ‚àÄt. W ‚áù t ‚áí t ‚àà œÄ`
  + and `W‚Üì sat œÄ ‚âú ‚àÄt. W‚Üì ‚áù t ‚áí t ‚àà œÄ`
- BCC (show): `‚àÄW t. W‚Üì ‚áù t ‚áí W ‚áù t`
- {.fragment} Let `W` be arbitrary. We need to show that `‚àÄt. W‚Üì ‚áù t ‚áí W ‚áù t`
- {.fragment} We instantiate TP with `W` and `œÄ = {t | W ‚áù t}`
  + We can since `W sat œÄ` holds trivially: `‚àÄt. W ‚áù t ‚áí W ‚áù t`
- {.fragment} This gives us that `W‚Üì sat œÄ ‚áî ‚àÄt. W‚Üì ‚áù t ‚áí W ‚áù t`. Qed.
- {.fragment} This simple proof thanks to Alix Trieu (Univ. Rennes)

## BCC often proved by simulation

- BCC can be proved by showing a **backwards simulation**\
  $s_t \to_a s_t' \wedge s_t \sim s_s \Rightarrow \exists s_s'.~ s_s \to_a s_s' \wedge s_t' \sim s_s'$
~ Snippet
\begin{tikzpicture}
\tikzstyle{all}= [draw, fill=blue!20,  minimum size=2em, rounded corners]
\tikzstyle{some}=[draw, fill=green!20, minimum size=2em, rounded corners]
\node[all]  (st)  at (0, 0) {$s_t$};
\node[all]  (st1) at (3, 0) {$s_t'$};
\node[all]  (ss)  at (0, 3) {$s_s$};
\node[some] (ss1) at (3, 3) {$\exists s_s'$};
\draw[->, blue,           thick, very near end, below=3em] (st) edge node {$a$} (st1);
\draw[->, black!60!green, thick, very near end, below=3em] (ss) edge node {$a$} (ss1);
% Large lengths don't seem to quite work
\draw[-, blue,           thick, decorate, decoration=snake, segment length=50] (ss)  -- (st);
\draw[-, black!60!green, thick, decorate, decoration=snake, segment length=50] (ss1) -- (st1);
\end{tikzpicture}
~
- {.fragment} leaving out `œÑ` transitions here, which add complications
[//]: <> ( TODO: It's exactly these left out steps that cause problems )
[//]: <> ( on the next slide )

## Backward simulations are hard to prove
- A single source expression often compiled to many machine instructions
- Have to look at the execution of many instructions before one can
  determine to what source expression it corresponded (decompilation)
- Optimizations can make this very difficult

## Forward simulation
- If languages are "well behaved" a **forward simulation** is enough:\
  $s_s \to_a s_s' \wedge s_t \sim s_s \Rightarrow \exists s_t'.~ s_t \to_a s_t' \wedge s_t' \sim s_s'$
~ Snippet
\begin{tikzpicture}
\tikzstyle{all}= [draw, fill=blue!20,  minimum size=2em, rounded corners]
\tikzstyle{some}=[draw, fill=green!20, minimum size=2em, rounded corners]
\node[all]  (st)  at (0, 0) {$s_t$};
\node[some] (st1) at (3, 0) {$\exists s_t'$};
\node[all]  (ss)  at (0, 3) {$s_s$};
\node[all]  (ss1) at (3, 3) {$s_s'$};
\draw[->, black!60!green, thick, very near end, below=3em] (st) edge node {$a$} (st1);
\draw[->, blue,           thick, very near end, below=3em] (ss) edge node {$a$} (ss1);
% Large lengths don't seem to quite work
\draw[-, blue,           thick, decorate, decoration=snake, segment length=50] (st)  -- (ss);
\draw[-, black!60!green, thick, decorate, decoration=snake, segment length=50] (st1) -- (ss1);
\end{tikzpicture}
~
- {.fragment} Theorem (trivial): If target is **deterministic** then forward simulation
  implies backward simulation.

## Determinism sufficient, not necessary

- Definition: We call a semantics `‚áù` **determinate** if
```
W‚áùt‚ÇÅ ‚àß W‚áùt‚ÇÇ ‚àß t‚ÇÅ‚â†t‚ÇÇ ‚áí ‚àÉm a‚ÇÅ‚â†a‚ÇÇ. input a‚ÇÅ ‚àß input a‚ÇÇ ‚àß m¬∑a‚ÇÅ ‚â§ t‚ÇÅ ‚àß m¬∑a‚ÇÇ ‚â§ t‚ÇÇ
```
  + no internal nondeterminism, all nondeterminism via external inputs

- {.fragment} Definition: We call a semantics `‚áù` **input total** (aka. receptive) if
```
input a‚ÇÅ ‚àß input a‚ÇÇ ‚àß W ‚áù*_{m¬∑a‚ÇÅ} ‚áí W ‚áù*_{m¬∑a‚ÇÇ}
```

- {.fragment} Theorem (Simplified from CompCert): If source is input total and
  target is determinate then forward simulation ‚áí backward simulation.
[//]: <> (  )
[//]: <> ( CompCert proof summarized in  )
[//]: <> ( <micro-policies-priv>/robust/compcert_events.txt )
[//]: <> ( but not simple enough to show )
[//]: <> (  )
[//]: <> ( TODO: Marco Vassena asked about "progress" (not getting stuck) )
[//]: <> ( assumptions on this kind of proof. I remember Xavier's course )
[//]: <> ( also had something about that, and Andrew's proof sketch too. )
[//]: <> ( Will need to double check on that! ) )

- {.fragment} You want to learn more about correct compilation?
  - Videos+materials of Xavier Leroy's DSSS'17 lectures are
    [available](https://deepspec.org/event/dsss17/lecture_leroy.html)
    [online](https://xavierleroy.org/courses/DSSS-2017/)

[//]: <> ( TODO: Would be a good exercise (for us at least) to redo all this course for a stack machine )
[//]: <> ( TODO: And to make it more real we could then port all this to target WebAssembly )

[//]: <> ( TODO: Finally, we could formalize the most interesting of these compilers in Coq, )
[//]: <> (       trying to keep things as simple and clean as possible. )
[//]: <> (       Maybe something to try with Arthur or Steven? )

## BCC is only about whole programs
- it doesn't allow separate compilation
- it doesn't allow linking with target code
  + even when that code is not malicious (e.g. verified)
- all correctness guarantees lost
- so let's first allow these easy cases
  (easier than secure compilation)

## 2-Linking and how it changes what a compiler chain is

- 2-Linking: Context + Partial Program = Whole Program
[//]: <> ( TODO repeated below )

- {.fragment} We extend both source and target with:
  - Two new syntactic categories:
    **contexts** (`C`) and **partial programs** (`P`)
  - Partial function to **link** C and P to produce a whole program W: C[P] = W
  - Compiler variants for **separately compiling** contexts and partial programs:
    P‚Çõ‚Üì = P‚Çú and C‚Çõ‚Üì = C‚Çú

- {.fragment} No constraints on what linking can do:
  - any of C and P can have initial control (e.g. define main), ...

## 2-Linking for our example
- Extending our source language (PROC+IO+2L):
  - {.fragment} `W ::= D‚ÇÅ,...,D‚Çô` ‚Äì where no procedure is defined twice,
     all used procedures are defined, and `main(arg) { e } ‚àà W‚Çõ`
  - {.fragment} `P,C‚Çõ ::= D‚ÇÅ,...,D‚Çô` ‚Äì where no procedure is defined twice
  - {.fragment} linking just concatenation (provided result is valid whole program):
```
    (D‚ÇÅ,...,D‚Çô)[D‚ÇÅ',...,D‚Çò'] = D‚ÇÅ,...,D‚Çô, D‚ÇÅ',...,D‚Çò'
```

- {.fragment} Extending our target language (REG+IO+2L):
  - `W‚Çú ::= instr‚ÇÅ;...;instr‚Çô` ‚Äì where no label is defined twice,
     and all used labels are defined
  - `P‚Çú,C‚Çú ::= vars_no, instr‚ÇÅ;...;instr‚Çô` ‚Äì no label is defined twice
  - linking concatenation + adding preamble (provided result is valid):
```
    (vars_no, instr‚ÇÅ,...,instr‚Çô)[vars_no', instr‚ÇÅ',...,instr‚Çò'] =
      Const 1 -> R_One; Const (vars_no + vars_no') -> R_SP;
      Jal label_of(main); Halt; instr‚ÇÅ;...;instr‚Çô;instr‚ÇÅ';...;instr‚Çò'
```

## 2-Linking for our example (continued)
- Compilation for partial programs / contexts:
  - If `C‚Çõ = D‚ÇÅ,...,D‚Çô` then `C‚Çõ‚Üì = |vars(C‚Çõ)|, D‚ÇÅ‚Üì; ...; D‚Çô‚Üì`
  - If `P = D‚ÇÅ,...,D‚Çô` then `P‚Üì = |vars(P)|, D‚ÇÅ‚Üì; ...; D‚Çô‚Üì`

[//]: <> ( TODO This slide is too short; just that it didn't fit on previous )

## Separate and Compositional Correct Compilation

- Separate Correct Compilation (SCC):
  `C‚Çõ‚Üì[P‚Üì] ‚áù t ‚áí C‚Çõ[P] ‚áù t`
  - This allows linking, but only with compiled contexts
    [//]: <> ( (i.e. not with arbitrary context built from the target language). )

- {.fragment} Compositional Correct Compilation (CCC):\
  `C‚Çú ‚âà C‚Çõ ‚àß C‚Çú[P‚Üì] ‚áù t ‚áí C‚Çõ[P] ‚áù t`
  - This allows linking with target contexts, but only if we know that
    they behave like a source-level context
  - e.g. produced by compilation, manually optimized and verified, etc

[//]: <> ( TODO: This theorem I skipped, it's anyway too obious )
[//]: <> ( - {.fragment} Theorem: Assuming that `‚àÄC‚Çõ. C‚Çõ‚Üì ‚âà C‚Çõ` we have CCC ‚áí SCC. )
[//]: <> (   - Let P C‚Çõ t so that C‚Çõ‚Üì[P‚Üì] ‚áù t. To show: C‚Çõ[P] ‚áù t )
[//]: <> (   - Since C‚Çõ‚Üì ‚âà C‚Çõ we can apply CCC to obtain C‚Çõ[P] ‚áù t )

[//]: <> ( TODO This was too much for Bertinoro, but still interesting for future courses )
[//]: <> ( Separate compilation property: )
[//]: <> ( `‚àÄP C‚Çõ t. C‚Çõ‚Üì[P‚Üì] ‚áù t ‚áî (C‚Çõ[P])‚Üì ‚áù t` )
[//]: <> ( + Whole program compilation of a linked source program should do the )
[//]: <> (   same as separate compilation followed by target linking )
[//]: <> ( + "separate compilation" property (later) holds syntactically for )
[//]: <> (   our compiler above: `C‚Çõ‚Üì[P‚Üì] = (C‚Çõ[P])‚Üì` )

[//]: <> ( <\!-- later diagram proof (rsc-diagram-bcc-fcc-reuse.png) will use )
[//]: <> (      separate compilation definition too! -\-> )

[//]: <> ( Theorem: Assuming that every whole program W can be split as some P and C‚Çõ )
[//]: <> ( (realistic), separate compilation implies that SCC is the same as BCC. )
[//]: <> ( Proof: )
[//]: <> ( - SCC ‚áí BCC. Let W and t so that W‚Üì ‚áù t. To show: W ‚áù t )
[//]: <> (   + by assumption ‚àÉP C‚Çõ, W = C‚Çõ[P] )
[//]: <> (   + by separate compilation from W‚Üì ‚áù t we get C‚Çõ‚Üì[P‚Üì] ‚áù t )
[//]: <> (   + by SCC: C‚Çõ[P] ‚áù t so W ‚áù t )
[//]: <> ( - BCC ‚áí SCC. Let C‚Çõ P t so that C‚Çõ‚Üì[P‚Üì] ‚áù t. To show: C‚Çõ[P] ‚áù t )
[//]: <> (   + by separate compilation: (C‚Çõ[P])‚Üì ‚áù t )
[//]: <> (   + by BCC: C‚Çõ[P] ‚áù t )

[//]: <> ( TODO (later): How does all this relate to Gil Hur's separate )
[//]: <> (               compilation work that got integrated in CompCert? ) )


[//]: <> ( under which assumption is the reverse true? )
[//]: <> ( - what if ‚âà is defined in terms of compilation, e.g. C‚Çõ ‚âà C‚Çú ‚âú C‚Çú = C‚Çõ‚Üì? )
[//]: <> (   then CCC becomes ‚àÄP C‚Çõ t. C‚Çõ‚Üì[P‚Üì] ‚áù t ‚áí C‚Çõ[P] ‚áù t, which is exactly SCC )
[//]: <> ( - this is an extreme kind of instantiation though! )

[//]: <> ( TODO (Catalin): more consistent notation in the past slides, )
[//]: <> (                 subscripts only for contexts )

## 2-Compartmentalized source language: PROC+IO+2‚ÑÇ

- PROC+IO+2L allows linking; we now extend this to components:
  - components have their own component-local variables
    + a source context C‚Çõ cannot write the program P's variables
  - more informative events:
    + so that discussing about robust satisfaction makes sense
  - abstractions of PROC+IO+2L and earlier are still there
    + e.g. the call-return discipline is still enforced at this level

- {.fragment} PROC+IO+2‚ÑÇ would be a good source for secure compilation chain

## PROC+IO+2‚ÑÇ syntax
[//]: <> ( - New syntactic class to identify "C" or "P": )
```
‚ÑÇ ::= "C" or "P"        component identifier
e ::= ...
    | x                 variables now interpreted per component (‚ÑÇ_cur.x)
      ...
    | ‚ÑÇ.P(e)            call to component ‚ÑÇ
    | return ‚ÑÇ e        return to component ‚ÑÇ after executing e

C‚Çõ,P ::= D‚ÇÅ,...,D‚Çô       where no procedure is defined twice

W ::= C.D‚ÇÅ,...,C.D‚Çô, P.D‚ÇÅ',...,P.D‚Çò'

Œ± ::= ...               more informative events
    | Input ‚ÑÇ i           visible input from ‚ÑÇ
    | Output ‚ÑÇ i          visible output from ‚ÑÇ
```

- {.fragment} Source linking of `C‚Çõ = D‚ÇÅ,...,D‚Çô` and `P = D‚ÇÅ',...,D‚Çò'`\
  (we keep track which procedures come from `C` and which ones from `P`)
```
C‚Çõ[P] ‚âú C.D‚ÇÅ,...,C.D‚Çô,P.D‚ÇÅ',...,P.D‚Çò'
```

## PROC+IO+2‚ÑÇ operational semantics:
- the variables of each component are fully separated from the others
  - we have to keep track of the current component ‚ÑÇ in the configuration

```
W ‚ä¢ ‚ÑÇ, M, x ‚ÜíœÑ ‚ÑÇ, M, M[‚ÑÇ,x]
W ‚ä¢ ‚ÑÇ, M, x:=i ‚Üí ‚ÑÇ, M[‚ÑÇ,x ‚Ü¶ i], i
...
W ‚ä¢ ‚ÑÇ‚ÇÅ, M, ‚ÑÇ‚ÇÇ.P(i) ‚ÜíœÑ ‚ÑÇ‚ÇÇ, M, e[arg‚Ü¶i]            when ‚ÑÇ‚ÇÇ.P(arg){e}‚ààW and ‚ÑÇ‚ÇÅ=‚ÑÇ‚ÇÇ
W ‚ä¢ ‚ÑÇ‚ÇÅ, M, ‚ÑÇ‚ÇÇ.P(i) ‚ÜíœÑ ‚ÑÇ‚ÇÇ, M, return ‚ÑÇ‚ÇÅ e[arg‚Ü¶i]  when ‚ÑÇ‚ÇÇ.P(arg){e}‚ààW and ‚ÑÇ‚ÇÅ‚â†‚ÑÇ‚ÇÇ
W ‚ä¢ ‚ÑÇ‚ÇÇ, M, return ‚ÑÇ‚ÇÅ i ‚ÜíœÑ ‚ÑÇ‚ÇÅ, M, i
...
W‚Çú ‚ä¢ ‚ÑÇ, M, R, PC ‚Üí_{Input ‚ÑÇ i} ‚ÑÇ, M, R[rd‚Ü¶i], PC+1      when W‚Çú[PC] = Input rd
W‚Çú ‚ä¢ ‚ÑÇ, M, R, PC ‚Üí_{Output ‚ÑÇ R[rs]} ‚ÑÇ, M, R, PC+1       when W‚Çú[PC] = Output rs

E ::= ... | return ‚ÑÇ E

InitS(W) = W ‚ä¢ ‚ÑÇ, [‚ÑÇ,x ‚Ü¶ 0 | ‚ÑÇ,x], main(0)  where ‚ÑÇ.main(arg){e} ‚àà W
```

## A correct but insecure compiler for PROC+IO+2‚ÑÇ
- We've just introduced one more source-level abstraction: components
- But a correct compiler can simply erase this abstraction going down
  [//]: <> ( (But a secure compiler has to enforce this abstraction.) )

- We can easily build a correct compiler from PROC+IO+2‚ÑÇ to REG+IO+2L
  (BCC, SCC, CCC) that is not at all secure.

- {.fragment} Compiled program and context share the same memory space:
  - addresses `  0,...,n-1  ` store C's variables
  - addresses `  n,...,n+m-1` store P's variables
  - addresses `n+m,...      ` store a shared stack

~Fragment
```
(‚ÑÇ, x)‚Üì = Const addr_of(‚ÑÇ,x) -> R_Aux; Load *R_Aux -> R_Res
(‚ÑÇ, x := e)‚Üì = (‚ÑÇ, e)‚Üì; Const addr_of(‚ÑÇ,x) -> R_Aux; Store R_Res -> *R_Aux
```
~

## A correct but insecure compiler (continued)

- Calls and returns compiled as before using `Jal` and `Jump`:
```
(‚ÑÇ, ‚ÑÇ.P(e))‚Üì = (‚ÑÇ, e)‚Üì; Push R_Arg, R_RA; Copy R_Res -> R_Arg; Jal label_of(‚ÑÇ.P);
                        Pop R_RA, R_Arg
(‚ÑÇ.P(arg) { e })‚Üì = Label label_of(‚ÑÇ.P); (‚ÑÇ, e)‚Üì; Jump R_RA
```

- {.fragment} Compilation for whole program `W = C.D‚ÇÅ,...,C.D‚Çô,P.D‚ÇÅ',...,P.D‚Çò'`:
```
W‚Üì = Const 1 -> R_One; Const |vars(W)| -> R_SP;
     Jal label_of(main); Halt; D‚ÇÅ‚Üì; ...; D‚Çô‚Üì; D‚ÇÅ'‚Üì; ...; D‚Çò'
```
  - basically as before, erases to which component a procedure belongs

- {.fragment} Compilation for partial programs and contexts:
  - If `C‚Çõ = D‚ÇÅ,...,D‚Çô` then `C‚Çõ‚Üì = |vars(C‚Çõ)|, D‚ÇÅ‚Üì; ...; D‚Çô‚Üì`
  - If `P = D‚ÇÅ,...,D‚Çô` then `P‚Üì = |vars(P)|, D‚ÇÅ‚Üì; ...; D‚Çô‚Üì`

[//]: <> ( TODO A lot of the last few was just repetition )

- {.fragment} Target linking:
```
(nv,instr‚ÇÅ;...;instr‚Çô)[mv,instr‚ÇÅ;...;instr‚Çò] =
    Const 1 -> R_One; Const (nv+mv) -> R_SP;
    Jal label_of(main); Halt; instr‚ÇÅ;...;instr‚Çô;instr‚ÇÅ;...;instr‚Çò
```

[//]: <> ( TODO This last one runs out of the slide )

## This compilation chain is correct but insecure

- This compilation chain satisfies BCC, SCC, CCC, so it is correct
  - it works if only using it for whole programs, or only linking with
    target contexts that are also compiled by ‚Üì, or which behave as if they were

- {.fragment} This compilation chain is insecure if linking
  **arbitrary** target contexts:
  - target context can write program's variables (shared memory)
  - target context can smash the shared stack, corrupt temporaries and
    return addresses, change the shared `R_SP` register at will
  - target context can jump to any program code (not just entry points)
  - but, since code is still immutable, target context can't write
    program's code (hurrah! one single abstraction protected!)

## Correct compilation is not enough

- We want to allow linking with **arbitrary** target code:
  - interoperate with code written in other languages\
    (e.g. libraries, host application)
  - implement things that are not possible in a high-level language
  - that's the way compiler chains are already used today!

- {.fragment} But linking in target code naively is insecure
  - target contexts have a lot of power over the program,
  - linked low-level code that is malicious or compromised can blatantly
    violate most source-level abstractions

# Secure interoperability with lower-level code

[//]: <> ( Secure (2-Compartmentalizing) Compilation as Robust Property Preservation )

[//]: <> ( ## Motivation )
[//]: <> ( return to powerpoint slides 3 (lower half), 5, 6, 7 )
[//]: <> ( other useful slides here: 9-12 )
[//]: <> ( ... and even 13 at the end, or when switching to hyperproperties )
[//]: <> ( CH: enough duplication already, so no )

## Robust Trace Property Preservation (RTP)

- TP: `‚àÄW œÄ‚àà2^Trace. W sat œÄ ‚áí W‚Üì sat œÄ`
  - where `W sat œÄ ‚âú ‚àÄt. W ‚áù t ‚áí t ‚àà œÄ`

- {.fragment} RTP: `‚àÄP œÄ‚àà2^Trace. P robustly sat œÄ ‚áí  P‚Üì robustly sat œÄ`
  - `P robustly sat œÄ ‚âú ‚àÄC‚Çõ. C‚Çõ[P] sat œÄ = ‚àÄC‚Çõ t. C‚Çõ[P]‚áùt ‚áí t‚ààœÄ`

- {.fragment} RTC: `‚àÄP C‚Çú t. C‚Çú[P‚Üì] ‚áù t ‚áí ‚àÉC‚Çõ. C‚Çõ[P] ‚áù t`

- {.fragment} RTP = what we want: source-level security reasoning
- {.fragment} RTC = how to prove it: produce `C‚Çõ` by "back-translating" `C‚Çú[P]‚áùt`

## RTP ‚áê RTC (easy)
```
RTC (know): ‚àÄP C‚Çú t. C‚Çú[P‚Üì]‚áùt ‚áí ‚àÉC‚Çõ. C‚Çõ[P]‚áùt
RTP (show): ‚àÄP œÄ. (‚àÄC‚Çõ t. C‚Çõ[P]‚áùt ‚áí t‚ààœÄ) ‚áí (‚àÄC‚Çú t. C‚Çú[P‚Üì]‚áùt ‚áí t‚ààœÄ)
```
+ {.fragment} Let `P` and `œÄ`, such that `‚àÄC‚Çõ t. C‚Çõ[P]‚áùt ‚áí t‚ààœÄ (H)`
+ {.fragment} Let `C‚Çú` and `t` such that `C‚Çú[P‚Üì]‚áùt`. To show: `t‚ààœÄ`
+ {.fragment} by RTC get `‚àÉC‚Çõ. C‚Çõ[P]‚áùt`
+ {.fragment} finally by instantiating (H) with `C‚Çõ` and `t` we get `t‚ààœÄ`

## RTP ‚áí RTC (Alix style, very simple)
```
RTP (know): ‚àÄP œÄ. (‚àÄC‚Çõ t. C‚Çõ[P]‚áùt ‚áí t‚ààœÄ) ‚áí (‚àÄC‚Çú t. C‚Çú[P‚Üì]‚áùt ‚áí t‚ààœÄ)
RTC (show): ‚àÄP C‚Çú t. C‚Çú[P‚Üì]‚áùt ‚áí ‚àÉC‚Çõ. C‚Çõ[P]‚áùt
```
+ {.fragment} Let `P`. To show: `‚àÄC‚Çú t. C‚Çú[P‚Üì]‚áùt ‚áí ‚àÉC‚Çõ. C‚Çõ[P]‚áùt`
+ {.fragment} Apply RTP with `P` and `œÄ={t|‚àÉC‚Çõ. C‚Çõ[P]‚áùt}`.
  - we can, since `‚àÄC‚Çõ t. C‚Çõ[P]‚áùt ‚áí ‚àÉC‚Çõ'. C‚Çõ'[P]‚áùt ` is trivially true
+ {.fragment} This gives us that `‚àÄC‚Çú t. C‚Çú[P‚Üì]‚áùt ‚áí ‚àÉC‚Çõ. C‚Çõ[P]‚áùt`. Done.

## RTP ‚áí RTC (our old proof, a bit more complex)
```
RTP (know): ‚àÄP œÄ. (‚àÄC‚Çõ t. C‚Çõ[P]‚áùt ‚áí t‚ààœÄ) ‚áí (‚àÄC‚Çú t. C‚Çú[P‚Üì]‚áùt ‚áí t‚ààœÄ)
          ‚áî ‚àÄP œÄ C‚Çú t. (C‚Çú[P‚Üì]‚áùt ‚àß t‚àâœÄ) ‚áí ‚àÉC‚Çõ t'. (C‚Çõ[P]‚áùt' ‚àß t'‚àâœÄ)
RTC (show): ‚àÄP C‚Çú t. C‚Çú[P‚Üì]‚áùt ‚áí ‚àÉC‚Çõ. C‚Çõ[P]‚áùt
```
+ {.fragment} Let `P`, `C‚Çú` and `t` such that `C‚Çú[P‚Üì]‚áùt`. To show: `‚àÉC‚Çõ. C‚Çõ[P]‚áùt`
+ {.fragment} Apply RTP contrapositive with `P`, `C‚Çú`, `t`, and `œÄ={t'|t'‚â†t}`.
  - We can do this since `C‚Çú[P‚Üì]‚áùt` and `t‚àâœÄ`.
+ {.fragment} This gives us that `‚àÉC‚Çõ t'. (C‚Çõ[P]‚áùt' ‚àß t'‚àâœÄ)`
+ {.fragment} Observe that `t'‚àâœÄ` implies `t'=t`. So we are done.
  - {.fragment} Double negation elimination, `t'‚àâœÄ ‚áî ¬¨(t'‚â†t) ‚áî t'=t`

[//]: <> ( TODO No need to show this any more next time )


## Finite trace prefixes, formally
```
t ::=                     traces
    | Œ±‚ÇÅ¬∑...¬∑Œ±‚Çô¬∑Done        succesful termination
    | Œ±‚ÇÅ¬∑...¬∑Œ±‚Çô¬∑Loop        silent divergence
    | Œ±‚ÇÅ¬∑...¬∑Œ±‚Çô¬∑...         infinite trace

m ::=                     finite trace prefixes
    | Œ±‚ÇÅ¬∑...¬∑Œ±‚Çô¬∑Done        succesful termination
    | Œ±‚ÇÅ¬∑...¬∑Œ±‚Çô¬∑Tbc         to be continued

m ‚â§ t                     prefix relation (inductive)

  Done ‚â§ Done         m ‚â§ t
                    ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
  Tbc ‚â§ t           Œ±¬∑m ‚â§ Œ±¬∑t
```

## Finite trace prefixes, intuitively

- Capture the observations that can be made about an execution
  in finite time, e.g. by a reference monitor (crucial for defining safety properties)
  - monitor can observe that the program has terminated
  - monitor can't observe divergence or silent divergence

- {.fragment} Previous trace models with only infinite traces
  - standard for defining (hyper)properties for reactive system models
  - unrealistic for non-reactive programs: programs can't terminate

- {.fragment} Previous trace models with finitely observable termination
  - often used for defining full abstraction
  - but unrealistic for a reference monitor (safety properties)

## Safety properties
- $\mathtt{Safety} \triangleq \{\pi \in 2^\mathtt{Trace} ~|~ \forall t\not\in\pi.~ \exists m {\leq} t.~ \forall t'{\geq} m.~ t'\not\in \pi \}$
  - $\pi$ is safety if, within any trace $t$ that violates $\pi$,
     there exists a finite "bad prefix" $m$ that can only be extended
     to traces $t'$ that also violate $\pi$

- {.fragment} $\pi_{\square\lnot\alpha} = \{t ~|~ \alpha \not\in t \} \in \mathtt{Safety}$
  [//]: <> ( - Program should never cause bad event $\alpha$. )
  - $t \not\in \{t ~|~ \alpha \not\in t\} \iff \alpha {\in} t \Rightarrow \exists m {=} m' {\cdot} \alpha {\cdot} \mathtt{Tbc}.~ m {\leq} t \wedge \forall t' {\geq} m.~ \alpha {\in} t'$
  
- {.fragment} $\pi_{\square\lnot \mathtt{Done}}= \{t ~|~ \mathtt{Done} \not\in t\}  \in \mathtt{Safety}$
  - Program should not terminate. Exercise: show that this is safety.

- {.fragment} $\pi_{\lozenge\alpha}^\mathtt{term} = \{ t ~|~ \mathtt{Done} \in t \Rightarrow \alpha \in t \} \in \mathtt{Safety}$
  [//]: <> ( - In every terminating trace the good event $\alpha$ must eventually happen. )
  - If program terminates without producing any $\alpha$ monitor knows that the property is violated.
    Exercise: show that $\pi_{\lozenge\alpha}^\mathtt{term}$ is safety.

- {.fragment} $\pi_{\lozenge\alpha} = \{ t ~|~ \alpha \in t \} \not\in \mathtt{Safety}$

[//]: <> ( Any trace property that allows all non-terminating traces )
[//]: <> ( is safety in our model (e.g. `\pi‚ñ°¬¨Done`, `\pi‚ãÑ\alpha^term`) )
[//]: <> ( - `t` terminating if `Done \in t`, )
[//]: <> ( - `t` non-terminating if `Done \not\in t`, )
[//]: <> (   i.e. t infinite or ends with `Loop` (silent divergence) )

[//]: <> ( Q: Can safety be defined using this? )
[//]: <> ( `Safety* = {\pi \in 2^Trace | \forall t non-terminating. t \in \pi}` )
[//]: <> ( - `\pi` is `Safety*` if it allows all non-terminating traces )
[//]: <> ( A: No! `\pi‚ñ°¬¨\alpha` above is intuitively safety, )
[//]: <> (    but it rejects some non-terminating traces. )

## Robust Safety Property Preservation (RSP)
- RSP: `‚àÄP œÄ‚ààSafety. P robustly sat œÄ ‚áí  P‚Üì robustly sat œÄ`

- {.fragment} RSC: `‚àÄP C‚Çú m. C‚Çú[P‚Üì] ‚áù* m ‚áí ‚àÉC‚Çõ. C‚Çõ[P] ‚áù* m`
  - where `W ‚áù* m ‚âú ‚àÉt‚â•m. W‚áùt`

- {.fragment} Theorem: `RSP ‚áî RSC`. Exercise: prove this.

- {.fragment} RSP is an interesting secure compilation criterion
  - easier to achieve and prove than most other criteria
  - still quite expressive:
    code and data integrity, but not confidentiality

[//]: <> ( TODO It would be nice to show, at least by example (e.g. on our example) )
[//]: <> ( why this usually captures code and data integrity )

## Example secure compilation chain satisfying RTP/RSP

## Target abstract machine REG+IO+2‚ÑÇ

- Goal #1: to provide enough protection to enforce RTP/RSP:
  - separated memory for each component for variables and local stacks
  - protected cross-component call stack

- Goal #2: keep things simple and independent of a particular enforcement mechanism

- {.fragment} Call and Return instructions, separated components

      instr ::= ...
              | Call ‚ÑÇ.P             call to component ‚ÑÇ
              | Return               return to top of protected stack

      CD ::=                       component declaration (record)
       {code=instr‚ÇÅ,...,instr‚Çô,           code of all its procedures
        entry_points=P‚ÇÅ‚Ü¶i‚ÇÅ, ..., P‚Çô‚Ü¶i‚Çô}   entry point of each procedure

      W‚Çú ::= C.CD‚ÇÅ, P.CD‚ÇÇ

[//]: <> ( Non Goal (yet) to be implementable by various enforcement mechanisms? )
[//]: <> ( Without abstract variable addresses, this machine is as unimplementable )
[//]: <> ( as Yannis' one on a single address space target machine! It could be )
[//]: <> ( implemented with processes and (infinite) virtual memory. )

## Semantics of REG+IO+2‚ÑÇ

- Each component's memory fully separated from the others;
  components can't even address each other's memory 
  
  [//]: <> ( (like in PROC+IO+2‚ÑÇ) )

      W‚Çú ‚ä¢ ‚ÑÇ, M, R, PC ‚ÜíœÑ ‚ÑÇ, M, R[R_RA‚Ü¶PC], offset(W‚Çú,‚ÑÇ,l)  when W‚Çú[‚ÑÇ,PC] = Jal l,
      W‚Çú ‚ä¢ ‚ÑÇ, M, R, PC ‚ÜíœÑ ‚ÑÇ, M, R, R[r]                     when W‚Çú[‚ÑÇ,PC] = Jump r
      W‚Çú ‚ä¢ ‚ÑÇ, M, R, PC ‚ÜíœÑ ‚ÑÇ, M, R, offset_of(W‚Çú,‚ÑÇ,l)  when W‚Çú[‚ÑÇ,PC]=Bnz r l and R[r]‚â†0
      W‚Çú ‚ä¢ ‚ÑÇ, M, R, PC ‚ÜíœÑ ‚ÑÇ, M, R, PC+1               when W‚Çú[‚ÑÇ,PC]=Bnz r l and R[r]=0

      W‚Çú ‚ä¢ ‚ÑÇ, M, R, PC ‚ÜíœÑ ‚ÑÇ, M, R[rd‚Ü¶M[‚ÑÇ,R[rp]]], PC+1  when W‚Çú[‚ÑÇ,PC]=Load *rp -> rd
      W‚Çú ‚ä¢ ‚ÑÇ, M, R, PC ‚ÜíœÑ ‚ÑÇ, M[‚ÑÇ,R[rp]‚Ü¶R[rs]], R, PC+1  when W‚Çú[‚ÑÇ,PC]=Store rs -> *rp

- {.fragment} Cross-component calls and returns use the protected call stack `œÉ`:

      W‚Çú ‚ä¢ ‚ÑÇ‚ÇÅ,œÉ,M,R,PC ‚Üí_{Call ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ.P(R[R_Arg])} ‚ÑÇ‚ÇÇ, (‚ÑÇ‚ÇÅ,PC+1)::œÉ, M, R, entry(W‚Çú,‚ÑÇ‚ÇÇ,P)
        when W‚Çú[‚ÑÇ‚ÇÅ,PC] = Call ‚ÑÇ‚ÇÇ.P and C‚ÇÅ ‚â† C‚ÇÇ (also statically checked)

      W‚Çú ‚ä¢ ‚ÑÇ‚ÇÇ, (‚ÑÇ‚ÇÅ,PC'::œÉ), M, R, PC ‚Üí_{Return ‚ÑÇ‚ÇÇ ‚ÑÇ‚ÇÅ R[R_Res]} ‚ÑÇ‚ÇÅ, œÉ, M, R, PC'
        when W‚Çú[‚ÑÇ‚ÇÇ,PC] = Return

[//]: <> ( More final states: )
[//]: <> ( - returning on an empty stack (dynamic error, machine stops) )
[//]: <> ( - using Call with same component (statically checked) )
[//]: <> ( - TODO: any other ones? )

## Secure compiler from PROC+IO+2‚ÑÇ to REG+IO+2‚ÑÇ

- REG+IO+2‚ÑÇ has a lot of built-in protection
- ... so the compiler doesn't have to do that much:
  - restore more registers after calling the other component
    + `R_SP`: this one can't be saved on the stack, using a variable
    + `R_One`: just write 1 back to it
  - also restore these registers after receiving cross-component calls
    and save them before giving back control
  - keep track of whether a procedure was called by the other component

[//]: <> ( TODO: could make this more interactive, ask students why the trivial compiler doesn't work )

[//]: <> ( (‚ÑÇ, x)‚Üì = Const addr_of(‚ÑÇ,x) -> R_Aux; Load *R_Aux -> R_Res )
[//]: <> ( (‚ÑÇ, x := e)‚Üì = (W‚Çõ, ‚ÑÇ, e)‚Üì; Const addr_of(‚ÑÇ,x) -> R_Aux; Store R_Res -> *R_Aux )

## Securely compiling procedures
```
(‚ÑÇ‚ÇÅ, ‚ÑÇ‚ÇÇ.P(e))‚Üì =
  If ‚ÑÇ‚ÇÅ = ‚ÑÇ‚ÇÇ Then
    (‚ÑÇ‚ÇÅ,e)‚Üì; Push R_Arg; Push R_RA; Copy R_Res -> R_Arg; Jal label_of(‚ÑÇ‚ÇÅ.P);
             Pop R_RA; Pop R_Arg
  Else
    (‚ÑÇ‚ÇÅ,e)‚Üì; Push R_Arg; Push R_RA; Copy R_Res -> R_Arg;
             Const addr_of(‚ÑÇ‚ÇÅ,xsp) -> R_Aux; Store R_SP -> *R_Aux;
             Call ‚ÑÇ‚ÇÇ.P;
             Const addr_of(‚ÑÇ‚ÇÅ,xsp) -> R_Aux; Load *R_Aux -> R_SP;
             Pop R_RA; Pop R_Arg; Const 1 -> R_One

(‚ÑÇ.P(arg) { e })‚Üì =
  Const addr_of(‚ÑÇ,xsp) -> R_Aux; Load *R_Aux -> R_SP; Const 1 -> R_One;
  (‚ÑÇ, e)‚Üì; Return;
  Label label_of(‚ÑÇ.P); (‚ÑÇ, e)‚Üì; Jump R_RA
```

## Exercise: improve compilation to not duplicate each procedure's body
~Fragment
Solution: use the stack to remember the entry point
```
(‚ÑÇ.P(arg) { e })‚Üì =
  Const addr_of(‚ÑÇ,xsp) -> R_Aux; Load *R_Aux -> R_SP; Const 1 -> R_One;
  Push R_One; Bnz R_One lexp;
  Label label_of(‚ÑÇ.P); Const 0 -> R_Aux; Push R_Aux;
  Label lexp; (‚ÑÇ, e)‚Üì; Pop R_Aux; Bnz R_Aux lcall;
  Jump R_RA; Label lcall; Return
```
Another solution: use an extra variable.
~

## An effective proof technique for RSP

## Partial semantics

- Captures the traces of a partial program when linked with any context

- Basically context abstracted away as nondeterminism

- We can actually define this generically, given a partialization
  function on complete states $\texttt{par}(cs,\mathbb{C})$:

$$
  \frac{
    \texttt{par}(cs,\mathbb{C}) = ps \quad
    \texttt{par}(cs',\mathbb{C}) = ps' \quad
    \quad cs \xrightarrow{\alpha} cs'}{ps \xrightharpoonup{\alpha} ps'}
$$

## Proof technique for RSP (basic version)
![basic](stuff/img/rsc-diagram-basic.png)

[//]: <> ( TODO: draw this in tikz )

[//]: <> ( Basic proof diagram: https://photos.app.goo.gl/LHeti93HQUwP7f9JA )

[//]: <> ( Ingredients: )
[//]: <> ( - partial semantics: composition and decomposition lemmas )
[//]: <> ( - back-translation for finite trace prefixes )
[//]: <> ( - BCC for partial semantics (by forward simulation if target determinate) )

## Complication #1: traces might not be informative enough for back-translation

[//]: <> ( This is not just hypothetical, it happens even in our example! )

- A trace prefix may correspond to several different executions:
```
m = Input C 0; Output P 1; Output P 2; Input C 3
```
- What procedure caused what inputs and outputs in the program `P`?
  + Need to know if we want to the backtranslated context to call the correct procedure

[//]: <> ( TODO: explained on the board why this could be hard to figure out )

## Solution: track component switches via informative traces

```
œï ::= ...               informative events
    | Call ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ.P(i)     cross-component call (‚ÑÇ‚ÇÅ‚â†‚ÑÇ‚ÇÇ)
    | Ret ‚ÑÇ‚ÇÇ ‚ÑÇ‚ÇÅ i         cross-component return (‚ÑÇ‚ÇÅ‚â†‚ÑÇ‚ÇÇ)

Œº ::=                   informative traces
    | œï‚ÇÅ¬∑...¬∑œï‚Çô¬∑Done        succesful termination
    | œï‚ÇÅ¬∑...¬∑œï‚Çô¬∑Loop        silent divergence
    | œï‚ÇÅ¬∑...¬∑œï‚Çô¬∑...         infinite trace

W ‚ä¢ ‚ÑÇ‚ÇÅ, M, ‚ÑÇ‚ÇÇ.P(i) ‚Üí_{Call ‚ÑÇ‚ÇÅ ‚ÑÇ‚ÇÇ.P(i)} ‚ÑÇ‚ÇÇ, M, return ‚ÑÇ‚ÇÅ e[arg‚Ü¶i]
  when ‚ÑÇ‚ÇÇ.P(arg){e}‚ààW and ‚ÑÇ‚ÇÅ‚â†‚ÑÇ‚ÇÇ

W ‚ä¢ ‚ÑÇ‚ÇÇ, M, return ‚ÑÇ‚ÇÅ i ‚Üí_{Ret ‚ÑÇ‚ÇÇ ‚ÑÇ‚ÇÅ} ‚ÑÇ‚ÇÅ, M, i
```

- A more informative trace could for instance be:
```
Œº = Input C 0; Call C P.P‚ÇÅ(0); Output P 1; Output P 2; Ret P C 0; Input C 3
```

## Proof technique with informative traces

![informative-traces](stuff/img/rsc-diagram-informative-traces.png)

[//]: <> ( New diagram (but adapted from Jeremy's setting, in which the context )
[//]: <> ( cannot cause events, so the ultimate sand-boxing): )
[//]: <> ( https://photos.app.goo.gl/gvrK1MNan5DF7VJ19 )

[//]: <> ( Note: Switching to informative traces can turn a finite trace to an )
[//]: <> ( infinite trace, in particular silent divergence to regular )
[//]: <> ( divergence. It can't turn a finite prefix into an infinite one though. )

[//]: <> ( Intuition: We are not back-translating finite traces, we are )
[//]: <> ( back-translating finite executions. )

## Backtranslation for our example

- Informative trace:
```
Œº = Input C 0; Call C P.P‚ÇÅ(0); Output P 1; Output P 2; Ret P C 0; Input C 3
```
- Can ignore what happens in the program:\
  `Output P 1; Output P 2; Ret P C 0`
- Only backtranslate the events produced by the context:
```
C‚Çõ = main(arg) { input; P.P‚ÇÅ(0); input }
```

## A more complicated back-translation example
+ Informative trace
``` 
Œº = Call P C.P‚ÇÅ(0); Ret C P 0; Call P C.P‚ÇÅ(1); Call C P.main(2)
```
+ {.fragment} Back-translation:
      C‚Çõ = P‚ÇÅ(arg) { if (i == 0) then 
                       i++; 0 
                     else if (i == 1) then
                       i++; P.main(2);
                     else
                       exit
          }
+ {.fragment} We can do this informative trace-based back-translation generically

[//]: <> ( TODO It would be a great exercise to ask for another such back-translation from the students )

## Complication #2: we might want to reuse a BCC proof for whole programs

![bcc-fcc-reuse](stuff/img/rsc-diagram-bcc-fcc-reuse.png)

[//]: <> ( diagram: https://photos.app.goo.gl/ttuvKXB7N4mxmsYs8 )

[//]: <> ( TODO The BCC + Separate Compilation arrow could be exactly SCC. )
[//]: <> ( TODO The FCC + Separate Compilation arrow could be a forward variant of SCC. )

## Complication #3: interfaces and static privileges

[//]: <> ( TODO: bring in all motivation why interfaces are needed from: )
[//]: <> ( - 3.3 RSC_DC_MD : Mutually Distrustful Components (CCS) )
[//]: <> ( - or CSF'16 even )

- We want to reason only about source contexts `C‚Çõ` with a
  certain interface, capturing its static privileges
  - for our languages interface = set of imported and exported procedures,
    whether input is allowed, whether output is allowed
  - target sandboxes components so they can't exceed their privileges

- {.fragment} RSP+I: `‚àÄIP. ‚àÄP:IP. ‚àÄœÄ‚ààSafety. ‚àÄIC‚ãàIP.`\
  `(‚àÄC‚Çõ:IC. C‚Çõ[P] sat œÄ) ‚áí (‚àÄC‚Çú:IC. C‚Çú[P‚Üì] sat œÄ)`

- {.fragment} RSC+I: `‚àÄIP‚ãàIC. ‚àÄP:IP. ‚àÄC‚Çú:IC. ‚àÄm.`\
  `C‚Çú[P‚Üì] ‚áù* m ‚áí ‚àÉC‚Çõ:IC. C‚Çõ[P] ‚áù* m`
  - our back-translation already produces `C‚Çõ` satisfying the interface `IC`

- {.fragment} We assume same interfaces for source and target languages

[//]: <> ( TODO: work out more how interfaces look in our compilation chain, )
[//]: <> (       actually do the extension )

[//]: <> ( TODO: show that RSP+I ‚áî RSC+I )

[//]: <> ( TODO: this becomes more interesting for mutually distrustful )
[//]: <> (       components written in unsafe source language )

## Robust Dense Property Preservation (RDP)
- The role of liveness is taken in our trace model by **dense properties**
  - in particular, in our model any trace property can be decomposed as the
    intersection of a safety property and a dense property
- {.fragment} `Dense ‚âú {œÄ ‚àà 2^Trace | ‚àÄt terminating. t ‚àà œÄ}`
  - `œÄ` is `Dense` if it allows all terminating traces
  - i.e. it can only be violated by non-terminating traces
- {.fragment} RDP: `‚àÄP œÄ‚ààDense. P robustly sat œÄ ‚áí  P‚Üì robustly sat œÄ`
- {.fragment} RDC: `‚àÄP. ‚àÄC‚Çú. ‚àÄt non-terminating. C‚Çú[P‚Üì]‚áùt ‚áí ‚àÉC‚Çõ. C‚Çõ[P]‚áùt`
- {.fragment} No known (infinite) trace-based technique for proving RDC

## Robust Hyperproperties Preservation

- RTP requires preserving code and data integrity, but not confidentiality

- {.fragment} RHP implies preserving **data confidentiality** (e.g. noninterference)

- {.fragment} Trace properties are properties of individual traces (`œÄ ‚àà 2^Trace`);\
  Hyperproperties relate multiple runs of a program (`H ‚àà 2^2^Trace`)

- {.fragment} `W sat œÄ ‚âú ‚àÄt. W‚áùt ‚áí t‚ààœÄ     ` `     W sat H ‚âú {t | W‚áùt} ‚àà H`

- {.fragment} RHP: `‚àÄP H‚àà2^2^Trace. P robustly sat H  ‚áí  P‚Üì robustly sat H`

- {.fragment} RHC: `‚àÄP C‚Çú. ‚àÉC‚Çõ. ‚àÄt. C‚Çú[P‚Üì] ‚áù t ‚áî C‚Çõ[P] ‚áù t`
  - quantifiers swapped, trace-based back-translation no longer possible
  - `‚áí` from RTC turned into `‚áî` in RHC (no refinement of nondeterminism)

## Robust Relational Hyperproperties Preservation

<!-- Recall that: -->
<!-- - RHP implies preserving **data confidentiality** (e.g. noninterference) -->
<!-- - Hyperproperties relate multiple runs of a single program\ -->

- Preserving **data and code confidentiality**
  - but code confidentiality hopeless with side-channels

- {.fragment} Relational hyperproperties relate multiple runs of **different** programs
  (e.g. trace equivalence relates the runs of 2 programs)

- {.fragment} R2rHP: `‚àÄP‚ÇÅ P‚ÇÇ R‚àà2^(2^Trace√ó2^Trace).(‚àÄC‚Çõ.({t|C‚Çõ[P‚ÇÅ]‚áùt},{t|C‚Çõ[P‚ÇÇ]‚áùt})‚ààR) ‚áí (‚àÄC‚Çú.({t|C‚Çú[P‚ÇÅ‚Üì]‚áùt},{t|C‚Çú[P‚ÇÇ‚Üì]‚áùt})‚ààR)`

- {.fragment} R2rHC: `‚àÄP‚ÇÅ P‚ÇÇ C‚Çú. ‚àÉC‚Çõ. (‚àÄt. C‚Çú[P‚ÇÅ‚Üì] ‚áù t ‚áî C‚Çõ[P‚ÇÅ] ‚áù t)`\
  `‚àß (‚àÄt. C‚Çú[P‚ÇÇ‚Üì] ‚áù t ‚áî C‚Çõ[P‚ÇÇ] ‚áù t)`

- {.fragment} this generalizes to relations of arbitrary arity, including infinite arity:
  - RrHC: `‚àÄC‚Çú. ‚àÉC‚Çõ. ‚àÄP. ‚àÄt. C‚Çú[P‚Üì] ‚áù t ‚áî C‚Çõ[P] ‚áù t`

## Open Research Problems

<http://prosecco.gforge.inria.fr/personal/hritcu/talks/2018-08-26-Fomally-Secure-Compilation-FOSAD-part1-intro.pdf#page=15>

[//]: <> ( return to powerpoint slide 15-16 (maybe also POPL paper and TODO.org) )
[//]: <> ( try to explain things in a bit more detail, e.g. 1 slide per probl)


# Secure Compartmentalizing Compilation for Unsafe Languages

<http://prosecco.gforge.inria.fr/personal/hritcu/talks/2018-08-26-Fomally-Secure-Compilation-FOSAD-part2-intro.pdf>

[//]: <> ( ## This is not only about C/C++ )
[//]: <> ( While C/C++ are notoriously bad in this respect, even safer languages )
[//]: <> ( have unsafe escape hatches: )
[//]: <> ( - unsafe blocks in Rust )
[//]: <> ( - Obj.magic in OCaml )
[//]: <> ( - unsafePerformIO in Haskell )
[//]: <> ( - reflection in Java/C#? )
[//]: <> ( The biggest such escape hatch for safer languages is often linking )
[//]: <> ( with unsafe low-level code (discussed in previous course) )

[//]: <> ( Software Security is a Programming Languages Issue http://www.pl-enthusiast.net/2018/08/13/security-programming-languages-issue/ )

[//]: <> ( ## last 10 min: Open Research Problems (again) )

# Table of contents

[TOC]
