(** * AltAuto: More Automation *)

Set Warnings "-notation-overridden,-parsing".
From Coq Require Import omega.Omega.
From LF Require Import IndProp.

(** Here's a function that rewrites regular expressions into
    potentially simpler forms without changing their matching
    behavior. *)

Fixpoint re_opt_e {T:Type} (re: reg_exp T) : reg_exp T :=
  match re with
  | App EmptyStr re2 => re_opt_e re2
  | App re1 re2 => App (re_opt_e re1) (re_opt_e re2)
  | Union re1 re2 => Union (re_opt_e re1) (re_opt_e re2)
  | Star re => Star (re_opt_e re)
  | _ => re
  end.

(** We would like to show the equivalence of re's with their "optimized" form.
One direction of this equivalence looks like this (the other is similar).
*)

Lemma re_opt_e_match : forall T (re: reg_exp T) s,
    s =~ re -> s =~ re_opt_e re.
Proof.
  intros T re s M.
  induction M
    as [| x'
        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2
        | s1 re1 re2 Hmatch IH | re1 s2 re2 Hmatch IH
        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2].
  - (* MEmpty *) simpl. apply MEmpty.
  - (* MChar *) simpl. apply MChar.
  - (* MApp *) simpl. 
    destruct re1. 
    + apply MApp. apply IH1. apply IH2.
    + inversion Hmatch1. simpl.  apply IH2.
    + apply MApp. apply IH1. apply IH2.
    + apply MApp. apply IH1. apply IH2.
    + apply MApp. apply IH1. apply IH2.
    + apply MApp. apply IH1. apply IH2.
  - (* MUnionL *) simpl. apply MUnionL. apply IH.
  - (* MUnionR *) simpl. apply MUnionR. apply IH.
  - (* MStar0 *) simpl. apply MStar0.
  - (* MStarApp *) simpl. apply MStarApp. apply IH1.  apply IH2. 
Qed.

(* ################################################################# *)
(** * Coq Automation *)

(** That last proof was getting a little repetitive.  Time to
    learn a few more Coq tricks... *)

(* ################################################################# *)
(** * Tacticals *)

(** _Tacticals_ is Coq's term for tactics that take other tactics as
    arguments -- "higher-order tactics," if you will.  *)

(* ----------------------------------------------------------------- *)
(** *** The [try] Tactical *)

(** If [T] is a tactic, then [try T] is a tactic that is just like [T]
    except that, if [T] fails, [try T] _successfully_ does nothing at
    all (instead of failing). *)

Theorem silly1 : forall n,  1 + n = S n.
Proof. try reflexivity. (* this just does [reflexivity] *) Qed.

Theorem silly2 : forall (P : Prop), P -> P.
Proof.
  intros P HP.
  try reflexivity. (* just [reflexivity] would have failed *)
  apply HP. (* we can still finish the proof in some other way *)
Qed.

(* ----------------------------------------------------------------- *)
(** *** The [;] Tactical (Simple Form) *)

(** In its most common form, the [;] tactical takes two tactics as
    arguments.  The compound tactic [T;T'] first performs [T] and then
    performs [T'] on _each subgoal_ generated by [T]. *)

(** For example: *)

Lemma foo : forall n, 0 <=? n = true.
Proof.
  intros.
  destruct n eqn:E.
    (* Leaves two subgoals, which are discharged identically...  *)
    - (* n=0 *) simpl. reflexivity.
    - (* n=Sn' *) simpl. reflexivity.
Qed.

(** We can simplify this proof using the [;] tactical: *)

Lemma foo' : forall n, 0 <=? n = true.
Proof.
  intros.
  (* [destruct] the current goal *)
  destruct n;
  (* then [simpl] each resulting subgoal *)
  simpl;
  (* and do [reflexivity] on each resulting subgoal *)
  reflexivity.
Qed.

(** Using [try] and [;] together, we can get rid of the repetition in
    the proof that was bothering us a little while ago. *)

Lemma re_opt_e_match' : forall T (re: reg_exp T) s,
    s =~ re -> s =~ re_opt_e re.
Proof.
  intros T re s M.
  induction M
    as [| x'
        | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2
        | s1 re1 re2 Hmatch IH | re1 s2 re2 Hmatch IH
        | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2];
    (* Do the [simpl] for every case here: *)
    simpl. 
  - (* MEmpty *) apply MEmpty.
  - (* MChar *) apply MChar.
  - (* MApp *) 
    destruct re1;
    (* Most cases follow by the same formula.
       Notice that [apply MApp] gives two subgoals:
       [try apply H1] is run on both of them and
       succeeds on the first but not the second;
       [apply H2] is then run on this remaining goal. *)
    try (apply MApp; try apply IH1; apply IH2).
    (* The interesting case, on which [try...] does nothing,
       is when [re1 = EmptyStr]. In this case, we have
       to appeal to the fact that [re1] matches only the
       empty string: *)
    inversion Hmatch1. simpl. apply IH2.
  - (* MUnionL *) apply MUnionL. apply IH.
  - (* MUnionR *) apply MUnionR. apply IH.
  - (* MStar0 *) apply MStar0.
  - (* MStarApp *)  apply MStarApp. apply IH1.  apply IH2. 
Qed.



(* ----------------------------------------------------------------- *)
(** *** The [repeat] Tactical *)

(** The [repeat] tactical takes another tactic and keeps applying this
    tactic until it fails. Here is an example showing that [10] is in
    a long list using repeat. *)

Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].
Proof.
  repeat (try (left; reflexivity); right).
Qed.

(* ================================================================= *)
(** ** A Few More Handy Tactics *)

(** By the way, here are some miscellaneous tactics that you may find
    convenient as we continue.

     - [clear H]: Delete hypothesis [H] from the context.

     - [rename... into...]: Change the name of a hypothesis in the
       proof context.  For example, if the context includes a variable
       named [x], then [rename x into y] will change all occurrences
       of [x] to [y].

     - [subst x]: Find an assumption [x = e] or [e = x] in the
       context, replace [x] with [e] throughout the context and
       current goal, and clear the assumption.

     - [subst]: Substitute away _all_ assumptions of the form [x = e]
       or [e = x].



    We'll see examples as we go along. *)

(* ================================================================= *)
(** ** Defining New Tactics *)

(** Coq also provides several ways of "programming" tactic scripts:
     - [Ltac]: scripting language for tactics (good for more
       sophisticated proof engineering)
     - OCaml tactic scripting API (only for wizards).
*)

(**    Here is a simple [Ltac] example: *)

Ltac impl_and_try c := simpl; try c.

(* ################################################################# *)
(** * Decision Procedures *)

(* ================================================================= *)
(** ** The Omega Tactic *)


Example silly_presburger_example : forall m n o p,
  m + n <= n + o /\ o + 3 = p + 3 ->
  m <= p.
Proof.
  intros. omega.
Qed.

(* ################################################################# *)
(** * Search Tactics *)

(* ================================================================= *)
(** ** The [constructor] tactic. *)

(** A simple first example of a search tactic is [constructor],
    which tries to find a constructor [c] (from some
    [Inductive] definition in the current environment) that can be
    applied to solve the current goal.  If one is found, behave
    like [apply c]. *) 

Example constructor_example: forall (n:nat),
    even (n+n).
Proof.
  induction n; simpl. 
  - constructor. (* applies ev_0 *)
  - rewrite plus_comm. simpl. constructor. (* applies ev_SS *) auto.
Qed.
    
(** This saves us from needing to remember the names of our constructors.
    Warning: if more than one constructor can apply, [constructor] picks
    the first one (in the order in which they were defined in the [Inductive])
    which is not necessarily the one we want! *)

(* ================================================================= *)
(** ** The [auto] Tactic *)

(** Thus far, our proof scripts mostly apply relevant hypotheses or
    lemmas by name, and one at a time. *)

Example auto_example_1 : forall (P Q R: Prop),
  (P -> Q) -> (Q -> R) -> P -> R.
Proof.
  intros P Q R H1 H2 H3.
  apply H2. apply H1. assumption.
Qed.

(** The [auto] tactic frees us from this drudgery by _searching_ for a
    sequence of applications that will prove the goal: *)

Example auto_example_1' : forall (P Q R: Prop),
  (P -> Q) -> (Q -> R) -> P -> R.
Proof.
  auto.
Qed.

(** The [auto] tactic solves goals that are solvable by any combination of
     - [intros] and
     - [apply] (of hypotheses from the local context, by default). *)

(** Here is a more interesting example showing [auto]'s power: *)

Example auto_example_2 : forall P Q R S T U : Prop,
  (P -> Q) ->
  (P -> R) ->
  (T -> R) ->
  (S -> T -> U) ->
  ((P->Q) -> (P->S)) ->
  T ->
  P ->
  U.
Proof. auto. Qed.

(** Proof search could, in principle, take an arbitrarily long time,
    so there are limits to how far [auto] will search by default. *)

Example auto_example_3 : forall (P Q R S T U: Prop),
  (P -> Q) ->
  (Q -> R) ->
  (R -> S) ->
  (S -> T) ->
  (T -> U) ->
  P ->
  U.
Proof.
  (* When it cannot solve the goal, [auto] does nothing *)
  auto.
  (* Optional argument says how deep to search (default is 5) *)
  auto 6.
Qed.

(** [auto] considers the hypotheses in the current context
    together with a _hint database_ of other lemmas and constructors.
    Some common facts about equality and logical operators are
    installed in the hint database by default. *)

Example auto_example_4 : forall P Q R : Prop,
  Q ->
  (Q -> R) ->
  P \/ (Q /\ R).
Proof. auto. Qed.

(** If we want to see which facts [auto] is using, we can use
    [info_auto] instead. *)

Example auto_example_5: 2 = 2.
Proof.
  (* auto subsumes reflexivity because eq_refl is in hint database *)
  info_auto.
Qed.

(** We can extend the hint database just for the purposes of one
    application of [auto] by writing "[auto using ...]". *)

Lemma le_antisym : forall n m: nat, (n <= m /\ m <= n) -> n = m.
Proof. intros. omega. Qed.

Example auto_example_6 : forall n m p : nat,
  (n <= p -> (n <= m /\ m <= n)) ->
  n <= p ->
  n = m.
Proof.
  intros.
  auto using le_antisym.
Qed.

(** We can also permanently extend the hint database:

      - [Hint Resolve T.]

          Add theorem or constructor [T] to the global DB

      - [Hint Constructors c.]

          Add _all_ constructors of [c] to the global DB

      - [Hint Unfold d.]

          Automatically expand defined symbol [d] during [auto]
*)

(** It is also possible to define specialized hint databases that can
    be activated only when needed.  See the Coq reference manual for
    more. *)

Hint Resolve le_antisym.

Example auto_example_6' : forall n m p : nat,
  (n<= p -> (n <= m /\ m <= n)) ->
  n <= p ->
  n = m.
Proof.
  intros.
  auto. (* picks up hint from database *)
Qed.

Definition is_fortytwo x := (x = 42).

Example auto_example_7: forall x,
  (x <= 42 /\ 42 <= x) -> is_fortytwo x.
Proof.
  auto.  (* does nothing *)
Abort.

Hint Unfold is_fortytwo.

Example auto_example_7' : forall x,
  (x <= 42 /\ 42 <= x) -> is_fortytwo x.
Proof. info_auto. Qed.


(* ================================================================= *)
(** ** The [eapply] and [eauto] variants *)

(** Consider this example: *)

Example trans_example1:  forall a b c d,
    a <= b + b*c  ->
    (1+c)*b <= d ->
    a <= d. 
Proof.
  intros a b c d H1 H2.
  apply le_trans with (b+ b*c).  (* <-- We must supply the intermediate value *)
  + apply H1.
  + simpl in H2. rewrite mult_comm. apply H2.
Qed.

(** If we leave out the [with], this step fails, because Coq cannot
    find an instance for the variable [n]. But this is silly! The appropriate
    value for [n] will become obvious in the very next step. *)

(** With [eapply], we can eliminate this silliness: *)

Example trans_example1':  forall a b c d,
    a <= b + b*c  ->
    (1+c)*b <= d ->
    a <= d. 
Proof.
  intros a b c d H1 H2.
  eapply le_trans.  (* 1 *)
  + apply H1.  (* 2 *)
  + simpl in H2. rewrite mult_comm. apply H2.
Qed.

(** Several of the tactics that we've seen so far, including [exists],
    [constructor], and [auto], have [e...] variants.  For example,
    here's a proof using [eauto]: *)

Example trans_example2:  forall a b c d,
    a <= b + b*c  ->
    b + b*c <= d ->
    a <= d. 
Proof.
  intros a b c d H1 H2.
  info_eauto using le_trans.
Qed.

(** The [eauto] tactic works just like [auto], except that it uses
    [eapply] instead of [apply].

    Pro tip: One might think that, since [eapply] and [eauto] are more
    powerful than [apply] and [auto], it would be a good idea to use
    them all the time.  Unfortunately, they are also significantly
    slower -- especially [eauto].  Coq experts tend to use [apply] and
    [auto] most of the time, only switching to the [e] variants when
    the ordinary variants don't do the job. *)

